package com.clarkson.sot.dungeon;

// Local project imports
import com.clarkson.sot.dungeon.segment.PlacedSegment;
import com.clarkson.sot.dungeon.segment.Segment;
import com.clarkson.sot.entities.Area; // Assuming Area class exists
import com.clarkson.sot.main.GameManager;
import com.clarkson.sot.main.SoT; // Or just Plugin

// Bukkit/WorldEdit imports
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.plugin.Plugin;
import org.bukkit.util.Vector;
import com.sk89q.worldedit.math.BlockVector3;

// Java imports
import java.util.*;
import java.util.logging.Level;
import java.util.stream.Collectors;

/**
 * Manages a specific, live instance of a dungeon for a single team.
 * Takes a DungeonBlueprint, translates it to absolute coordinates,
 * builds the instance in the world, and holds the final Dungeon data object.
 */
public class DungeonManager {

    // --- Dependencies ---
    private final Plugin plugin;
    private final GameManager gameManager;
    private final DungeonGenerator dungeonGenerator; // Still needed for pasting utility
    private final VaultManager vaultManager;

    // --- Instance State ---
    private final UUID teamId;
    private final Location dungeonOrigin; // Absolute world origin for this instance
    private final World world;
    private final DungeonBlueprint blueprintData; // The relative blueprint
    private final List<PlacedSegment> placedSegments; // Actual instances in the world for this team

    // The consolidated data object with ABSOLUTE locations for this instance
    private Dungeon dungeonData;

    /**
     * Constructor for a team's specific DungeonManager instance.
     *
     * @param plugin           The main plugin instance.
     * @param gameManager      The main GameManager.
     * @param dungeonGenerator The DungeonGenerator utility (for pasting).
     * @param vaultManager     The VaultManager.
     * @param teamId           The UUID of the team this dungeon belongs to.
     * @param dungeonOrigin    The absolute world location for the origin (0,0,0 point) of this dungeon instance.
     * @param blueprintData    The relative layout blueprint generated by DungeonGenerator.
     */
    public DungeonManager(Plugin plugin, GameManager gameManager, DungeonGenerator dungeonGenerator,
                          VaultManager vaultManager, UUID teamId, Location dungeonOrigin, DungeonBlueprint blueprintData) {

        this.plugin = Objects.requireNonNull(plugin, "Plugin cannot be null");
        this.gameManager = Objects.requireNonNull(gameManager, "GameManager cannot be null");
        this.dungeonGenerator = Objects.requireNonNull(dungeonGenerator, "DungeonGenerator cannot be null");
        this.vaultManager = Objects.requireNonNull(vaultManager, "VaultManager cannot be null");
        this.teamId = Objects.requireNonNull(teamId, "Team ID cannot be null");
        this.dungeonOrigin = Objects.requireNonNull(dungeonOrigin, "Dungeon origin cannot be null");
        this.world = Objects.requireNonNull(dungeonOrigin.getWorld(), "Dungeon origin must have a valid world");
        this.blueprintData = Objects.requireNonNull(blueprintData, "Dungeon blueprint cannot be null");

        this.placedSegments = new ArrayList<>(); // Populated during initialization
        this.dungeonData = null; // Created during initialization
    }

    /**
     * Initializes the dungeon instance in the world.
     * 1. Creates the absolute Dungeon data object from the blueprint.
     * 2. Pastes segments based on the absolute locations.
     * 3. Populates features based on the absolute locations.
     * 4. Places vaults/keys based on the absolute locations.
     *
     * @return true if initialization was generally successful, false otherwise.
     */
    public boolean initializeInstance() {
        try {
            plugin.getLogger().info("Initializing dungeon instance for team " + teamId + " at " + dungeonOrigin.toVector());
            placedSegments.clear(); // Ensure clear before starting

            // --- 1. Create Absolute Dungeon Data & PlacedSegment Instances ---
            if (!createAbsoluteInstanceData()) {
                plugin.getLogger().severe("Failed to create absolute instance data for team " + teamId);
                return false;
            }
            // Now this.dungeonData and this.placedSegments are populated with absolute locations

            // --- 2. Paste Segments ---
            plugin.getLogger().info("Pasting segments for team " + teamId + "...");
            boolean pastingOk = true;
            for (PlacedSegment instanceSegment : this.placedSegments) {
                if (!dungeonGenerator.pasteSegmentInstance(instanceSegment)) {
                    plugin.getLogger().severe("CRITICAL: Failed to paste segment " + instanceSegment.getName() + " for team " + teamId + ". Dungeon may be incomplete.");
                    pastingOk = false; // Mark failure
                }
            }
            if (!pastingOk) {
                plugin.getLogger().severe("Dungeon instance for team " + teamId + " may be incomplete due to pasting errors.");
                // return false; // Decide if this is fatal
            }

            // --- 3. Populate Features (using absolute locations from dungeonData) ---
            plugin.getLogger().info("Populating features for team " + teamId + "...");
            populateFeaturesFromData();

            // --- 4. Place Vaults & Keys (using absolute locations from dungeonData) ---
            plugin.getLogger().info("Placing vaults and keys for team " + teamId + "...");
            // VaultManager now uses the Dungeon object containing absolute locations
            if (!vaultManager.placeVaultMarkersAndKeyItems(this.teamId, this.dungeonData)) {
                plugin.getLogger().warning("Failed to place some vaults/keys for team " + teamId);
            }

            plugin.getLogger().info("Dungeon instance initialization complete for team " + teamId);
            return true;

        } catch (Exception e) {
            plugin.getLogger().log(Level.SEVERE, "Unexpected error during dungeon instance initialization for team " + teamId, e);
            return false;
        }
    }

    /**
     * Creates the `Dungeon` data object (with absolute locations) and the
     * list of `PlacedSegment` instances (with absolute origins) from the blueprint data.
     * Populates `this.dungeonData` and `this.placedSegments`.
     * @return true if successful, false otherwise.
     */
    private boolean createAbsoluteInstanceData() {
        this.placedSegments.clear();
        Map<VaultColor, Location> vaultMarkerLocs = new HashMap<>();
        Map<VaultColor, Location> keySpawnLocs = new HashMap<>();
        List<Location> sandSpawnLocs = new ArrayList<>();
        List<Location> coinSpawnLocs = new ArrayList<>();
        List<Location> itemSpawnLocs = new ArrayList<>();
        Location foundHubLocation = null;

        // Create PlacedSegment instances with absolute origins
        for (PlacedSegment relativeSegment : blueprintData.getRelativeSegments()) {
            Location relativeOrigin = relativeSegment.getWorldOrigin(); // Origin relative to blueprint 0,0,0
            Location absoluteOrigin = dungeonOrigin.clone().add(relativeOrigin.toVector());
            absoluteOrigin.setWorld(world);
            this.placedSegments.add(new PlacedSegment(relativeSegment.getSegmentTemplate(), absoluteOrigin));
        }

        // Translate relative blueprint locations to absolute world locations
        Vector originVec = dungeonOrigin.toVector(); // Vector representation of the absolute origin

        // Hub Location
        if (blueprintData.getHubRelativeLocation() != null) {
            foundHubLocation = blueprintData.getHubRelativeLocation().toLocation(world).add(originVec);
        } else {
             plugin.getLogger().warning("Hub relative location missing in blueprint for team " + teamId);
             // Attempt to find hub segment origin as fallback
             for(PlacedSegment ps : this.placedSegments) {
                 if(ps.getSegmentTemplate().isHub()) {
                     foundHubLocation = ps.getWorldOrigin();
                     break;
                 }
             }
             if(foundHubLocation == null) plugin.getLogger().severe("Could not determine Hub location for team " + teamId);
        }


        // Vault Markers
        blueprintData.getVaultMarkerRelativeLocations().forEach((color, relVec) -> {
            vaultMarkerLocs.put(color, relVec.toLocation(world).add(originVec));
        });

        // Key Spawns
        blueprintData.getKeySpawnRelativeLocations().forEach((color, relVec) -> {
            keySpawnLocs.put(color, relVec.toLocation(world).add(originVec));
        });

        // Sand Spawns
        blueprintData.getSandSpawnRelativeLocations().forEach(relVec -> {
            sandSpawnLocs.add(relVec.toLocation(world).add(originVec));
        });

        // Coin Spawns
        blueprintData.getCoinSpawnRelativeLocations().forEach(relVec -> {
            coinSpawnLocs.add(relVec.toLocation(world).add(originVec));
        });

        // Item Spawns
        blueprintData.getItemSpawnRelativeLocations().forEach(relVec -> {
            itemSpawnLocs.add(relVec.toLocation(world).add(originVec));
        });

        // Create the Dungeon data object
        this.dungeonData = new Dungeon(
                teamId, dungeonOrigin, world, placedSegments,
                foundHubLocation, vaultMarkerLocs, keySpawnLocs,
                sandSpawnLocs, coinSpawnLocs, itemSpawnLocs
        );

        return true; // Assume success for now
    }


    /**
     * Helper method to spawn dynamic elements using the pre-calculated absolute locations
     * stored in the `dungeonData` object. Called by `initializeInstance`.
     */
    private void populateFeaturesFromData() {
        if (dungeonData == null) {
            plugin.getLogger().severe("Cannot populate features: Dungeon data object is null for team " + teamId);
            return;
        }

        // Populate Sand
        for (Location absLoc : dungeonData.getSandSpawnLocations()) {
            try {
                Block block = absLoc.getBlock();
                if (block.isPassable() || block.getType().isAir() || block.isLiquid()) {
                    block.setType(Material.SAND, false);
                }
            } catch (Exception e) {
                plugin.getLogger().log(Level.WARNING, "Error placing sand at " + absLoc.toVector() + " for team " + teamId, e);
            }
        }

        // Populate Coins
        // TODO: Implement actual coin spawning using FloorItemManager or similar
        for (Location absLoc : dungeonData.getCoinSpawnLocations()) {
            // Example: Spawn placeholder item
            // ItemStack coin = new ItemStack(Material.GOLD_NUGGET);
            // world.dropItemNaturally(absLoc.clone().add(0.5, 0.5, 0.5), coin);
        }

        // Populate Items
        // TODO: Implement actual item spawning (loot tables etc.)
        for (Location absLoc : dungeonData.getItemSpawnLocations()) {
             // Example: Spawn placeholder item
             // ItemStack item = new ItemStack(Material.DIAMOND);
             // world.dropItemNaturally(absLoc.clone().add(0.5, 0.5, 0.5), item);
        }
         plugin.getLogger().fine("Populated features from data for team " + teamId);
    }


    /**
     * Returns the absolute world location of this dungeon instance's origin (0,0,0 point).
     */
    public Location getDungeonOrigin() {
        return dungeonOrigin;
    }

    /**
     * Returns the Bukkit World object where this dungeon instance exists.
     */
    public World getWorld() {
        return world;
    }

    /**
     * Finds which specific PlacedSegment instance within this dungeon contains the
     * given absolute world location.
     */
    public PlacedSegment getSegmentAtLocation(Location location) {
        if (this.dungeonData != null) {
            return this.dungeonData.getSegmentAt(location); // Assumes Dungeon.getSegmentAt implemented
        } else {
            // Fallback if called too early (shouldn't happen in normal flow)
             plugin.getLogger().warning("getSegmentAtLocation called before dungeonData was initialized for team " + teamId);
             return null;
        }
    }

    /**
     * Returns the UUID of the team that owns this dungeon instance.
     */
    public UUID getTeamId() {
        return teamId;
    }

    /**
     * Returns the consolidated Dungeon data object containing pre-calculated locations
     * for this instance. Returns null if initializeInstance hasn't completed.
     */
    public Dungeon getDungeonData() {
        return dungeonData;
    }

    /**
     * Returns an unmodifiable list of the actual PlacedSegment instances that make up
     * this dungeon instance in the world.
     */
    public List<PlacedSegment> getPlacedSegments() {
        return Collections.unmodifiableList(this.placedSegments);
    }

    /**
     * Removes the blocks and entities associated with this dungeon instance. (Optional)
     */
    public void cleanupInstance() {
        plugin.getLogger().info("Attempting cleanup for dungeon instance of team " + teamId);
        // TODO: Implement cleanup logic (e.g., WorldEdit //set air)
        placedSegments.clear();
        dungeonData = null;
        plugin.getLogger().info("Cleanup logic finished for team " + teamId);
    }
}
