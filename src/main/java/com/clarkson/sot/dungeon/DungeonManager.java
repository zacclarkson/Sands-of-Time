package com.clarkson.sot.dungeon;

// Local project imports
import com.clarkson.sot.dungeon.segment.PlacedSegment;
import com.clarkson.sot.dungeon.segment.Segment;
import com.clarkson.sot.entities.Area;
import com.clarkson.sot.dungeon.DoorManager; // Import DoorManager
import com.clarkson.sot.events.FloorItemManager;
import com.clarkson.sot.main.GameManager;
import com.clarkson.sot.main.SoT; // Or just Plugin

// Bukkit/WorldEdit imports
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.plugin.Plugin;
import org.bukkit.util.Vector;
import com.sk89q.worldedit.math.BlockVector3;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

// WorldEdit imports for pasting (Example - move to dedicated class later)
import com.sk89q.worldedit.WorldEdit;
import com.sk89q.worldedit.bukkit.BukkitAdapter;
import com.sk89q.worldedit.extent.clipboard.Clipboard;
import com.sk89q.worldedit.extent.clipboard.io.ClipboardFormat;
import com.sk89q.worldedit.extent.clipboard.io.ClipboardFormats;
import com.sk89q.worldedit.extent.clipboard.io.ClipboardReader;
import com.sk89q.worldedit.session.ClipboardHolder;
import com.sk89q.worldedit.EditSession;
import com.sk89q.worldedit.function.operation.Operation;
import com.sk89q.worldedit.function.operation.Operations;
import com.sk89q.worldedit.WorldEditException;


// Java imports
import java.io.File; // For schematic file path
import java.io.FileInputStream; // For schematic reading
import java.io.IOException; // For schematic reading
import java.util.*;
import java.util.logging.Level;
import java.util.stream.Collectors;

/**
 * Manages a specific, live instance of a dungeon for a single team.
 * Takes a DungeonBlueprint, translates it to absolute coordinates,
 * builds the instance in the world using WorldEdit, initializes features,
 * and holds the final Dungeon data object.
 */
public class DungeonManager {

    // --- Dependencies ---
    private final Plugin plugin;
    private final GameManager gameManager;
    // Managers retrieved from GameManager
    private final VaultManager vaultManager;
    private final FloorItemManager floorItemManager;
    private final DoorManager doorManager;

    // --- Instance State ---
    private final UUID teamId;
    private final Location dungeonOrigin; // Absolute world origin for this instance
    private final World world;
    private final DungeonBlueprint blueprintData; // The relative blueprint used
    private final List<PlacedSegment> placedSegmentsInWorld; // Actual segments placed in the world

    // The consolidated data object with ABSOLUTE locations for this instance
    private Dungeon dungeonData;

    /**
     * Constructor for a team's specific DungeonManager instance.
     * Retrieves dependent managers from GameManager.
     *
     * @param plugin           The main plugin instance.
     * @param gameManager      The main GameManager (used to get other managers).
     * @param teamId           The UUID of the team this dungeon belongs to.
     * @param dungeonOrigin    The absolute world location for the origin (0,0,0 point) of this dungeon instance.
     * @param blueprintData    The relative layout blueprint generated by DungeonGenerator.
     */
    public DungeonManager(@NotNull Plugin plugin, @NotNull GameManager gameManager,
                          @NotNull UUID teamId, @NotNull Location dungeonOrigin, @NotNull DungeonBlueprint blueprintData) {

        this.plugin = Objects.requireNonNull(plugin, "Plugin cannot be null");
        this.gameManager = Objects.requireNonNull(gameManager, "GameManager cannot be null");
        // Get managers from GameManager (ensure GameManager provides non-null getters)
        this.vaultManager = Objects.requireNonNull(gameManager.getVaultManager(), "VaultManager cannot be null via GameManager");
        this.floorItemManager = Objects.requireNonNull(gameManager.getFloorItemManager(), "FloorItemManager cannot be null via GameManager");
        this.doorManager = Objects.requireNonNull(gameManager.getDoorManager(), "DoorManager cannot be null via GameManager");
        // ---
        this.teamId = Objects.requireNonNull(teamId, "Team ID cannot be null");
        this.dungeonOrigin = Objects.requireNonNull(dungeonOrigin, "Dungeon origin cannot be null");
        this.world = Objects.requireNonNull(dungeonOrigin.getWorld(), "Dungeon origin must have a valid world");
        this.blueprintData = Objects.requireNonNull(blueprintData, "Dungeon blueprint cannot be null");

        this.placedSegmentsInWorld = new ArrayList<>(); // Populated during initialization
        this.dungeonData = null; // Created during initialization
    }

    /**
     * Initializes the dungeon instance in the world.
     * 1. Calculates absolute locations for features.
     * 2. Pastes segments based on the absolute locations.
     * 3. Creates the Dungeon data object.
     * 4. Initializes Vaults, Keys, Doors, and FloorItems using their respective managers.
     *
     * @return true if initialization was generally successful, false otherwise.
     */
    public boolean initializeInstance() {
        plugin.getLogger().info("Initializing dungeon instance for team " + teamId + " at origin " + dungeonOrigin.toVector());

        // --- 1. Calculate Absolute Locations ---
        Map<VaultColor, Location> absVaultMarkers = calculateAbsoluteLocations(blueprintData.getVaultMarkerRelativeLocations());
        Map<VaultColor, Location> absKeySpawns = calculateAbsoluteLocations(blueprintData.getKeySpawnRelativeLocations());
        List<Location> absSandSpawns = calculateAbsoluteLocations(blueprintData.getSandSpawnRelativeLocations());
        List<Location> absCoinSpawns = calculateAbsoluteLocations(blueprintData.getCoinSpawnRelativeLocations());
        List<Location> absItemSpawns = calculateAbsoluteLocations(blueprintData.getItemSpawnRelativeLocations());
        Location absHubLocation = dungeonOrigin.clone().add(blueprintData.getHubRelativeLocation());


        // --- 2. Paste Schematics (Populates placedSegmentsInWorld) ---
        if (!pasteSegmentSchematics()) {
             plugin.getLogger().severe("Failed to paste one or more schematics for team " + teamId);
             return false;
        }
        plugin.getLogger().info("Pasted all " + placedSegmentsInWorld.size() + " segment schematics for team " + teamId);


        // --- 3. Create Dungeon Data Object ---
        // Now created *after* pasting. Uses the calculated absolute locations.
        // The Dungeon constructor no longer takes the PlacedSegment list.
         try {
            this.dungeonData = new Dungeon(
                teamId, world, dungeonOrigin, blueprintData, // Pass blueprint ref
                absHubLocation, absVaultMarkers, absKeySpawns,
                absSandSpawns, absCoinSpawns, absItemSpawns
            );
             plugin.getLogger().info("Created Dungeon data object for team " + teamId);
         } catch (Exception e) {
             plugin.getLogger().log(Level.SEVERE, "Exception creating Dungeon data object for team " + teamId, e);
             return false;
         }


        // --- 4. Initialize Features using Managers ---
        // These managers use the absolute locations stored in dungeonData
        try {
            vaultManager.initializeForInstance(this.dungeonData);
            doorManager.initializeDoorsForInstance(this.dungeonData); // Initialize doors
            populateFloorItems(); // Spawn floor items
        } catch (Exception e) {
             plugin.getLogger().log(Level.SEVERE, "Error during feature manager initialization for team " + teamId, e);
             return false;
        }

        plugin.getLogger().info("Successfully initialized dungeon instance for team " + teamId);
        return true;
    }

    // createDungeonDataObject() removed as logic moved into initializeInstance()

    /** Helper to convert relative map to absolute map */
    private Map<VaultColor, Location> calculateAbsoluteLocations(Map<VaultColor, Vector> relativeMap) {
        Map<VaultColor, Location> absoluteMap = new HashMap<>();
        for (Map.Entry<VaultColor, Vector> entry : relativeMap.entrySet()) {
            absoluteMap.put(entry.getKey(), dungeonOrigin.clone().add(entry.getValue()));
        }
        return absoluteMap;
    }

    /** Helper to convert relative list to absolute list */
    private List<Location> calculateAbsoluteLocations(List<Vector> relativeList) {
        return relativeList.stream()
                           .map(vec -> dungeonOrigin.clone().add(vec))
                           .collect(Collectors.toList());
    }


    /** Pastes all segment schematics into the world at their absolute locations. */
    private boolean pasteSegmentSchematics() {
        this.placedSegmentsInWorld.clear(); // Start fresh for this instance

        for (PlacedSegment blueprintSegment : blueprintData.getRelativeSegments()) {
            Segment template = blueprintSegment.getSegmentTemplate();
            Vector relativeOriginVec = blueprintSegment.getWorldOrigin().toVector(); // Origin relative to blueprint 0,0,0
            Location absoluteOriginLoc = dungeonOrigin.clone().add(relativeOriginVec); // Absolute world location to paste at

            // --- Call Pasting Logic ---
            boolean success = pasteSchematic(template, absoluteOriginLoc); // Use helper
            if (!success) {
                plugin.getLogger().severe("Failed to paste schematic '" + template.getSchematicFileName() + "' for team " + teamId + " at " + absoluteOriginLoc.toVector());
                return false; // Stop if one fails? Or continue? For now, stop.
            }

            // Create a new PlacedSegment representing the actual world placement
            // Use the ABSOLUTE location now
            PlacedSegment worldSegment = new PlacedSegment(template, absoluteOriginLoc, blueprintSegment.getDepth());
            this.placedSegmentsInWorld.add(worldSegment);
            plugin.getLogger().finer("Pasted segment " + template.getName() + " for team " + teamId + " at " + absoluteOriginLoc.toVector());
        }
        return true;
    }

    /** Pastes a single schematic using WorldEdit. */
    private boolean pasteSchematic(Segment template, Location pasteOrigin) {
         // Use File path relative to plugin data folder
         File schematicDir = new File(plugin.getDataFolder(), "schematics");
         File schematicFile = new File(schematicDir, template.getSchematicFileName());

         if (!schematicFile.exists()) {
             plugin.getLogger().severe("Schematic file not found: " + schematicFile.getPath());
             return false;
         }

         try {
             ClipboardFormat format = ClipboardFormats.findByFile(schematicFile);
             if (format == null) {
                  plugin.getLogger().severe("Unknown schematic format: " + schematicFile.getName());
                  return false;
             }
             try (ClipboardReader reader = format.getReader(new FileInputStream(schematicFile))) {
                 Clipboard clipboard = reader.read();
                 com.sk89q.worldedit.world.World weWorld = BukkitAdapter.adapt(pasteOrigin.getWorld());

                 try (EditSession editSession = WorldEdit.getInstance().newEditSessionBuilder().world(weWorld).build()) {
                     Operation operation = new ClipboardHolder(clipboard)
                             .createPaste(editSession)
                             .to(BlockVector3.at(pasteOrigin.getBlockX(), pasteOrigin.getBlockY(), pasteOrigin.getBlockZ()))
                             .ignoreAirBlocks(true) // Paste non-air blocks
                             .build();
                     Operations.complete(operation);
                 }
             }
             return true;
         } catch (IOException | WorldEditException e) {
              plugin.getLogger().log(Level.SEVERE, "Failed to paste schematic " + template.getSchematicFileName() + " at " + pasteOrigin.toVector(), e);
              return false;
         } catch (Exception e) {
             plugin.getLogger().log(Level.SEVERE, "Unexpected error pasting schematic " + template.getSchematicFileName(), e);
             return false;
         }
    }


    /** Spawns floor items using the FloorItemManager. */
    private void populateFloorItems() {
        if (dungeonData == null) { /* ... error log ... */ return; }
        plugin.getLogger().fine("Populating floor items for team " + teamId);

        // Populate Coins
        for (Location absLoc : dungeonData.getCoinSpawnLocations()) {
            int baseValue = 5; // TODO: Get value based on depth/segment
            int depth = dungeonData.getDepthAtLocation(absLoc, this.placedSegmentsInWorld); // Pass placed segments
            floorItemManager.spawnCoinStack(absLoc, baseValue, teamId, dungeonData.getInstanceId(), depth);
        }

        // Populate Items
        for (Location absLoc : dungeonData.getItemSpawnLocations()) {
             int depth = dungeonData.getDepthAtLocation(absLoc, this.placedSegmentsInWorld); // Pass placed segments
            floorItemManager.spawnGenericItem(absLoc, teamId, dungeonData.getInstanceId(), depth);
        }

        // Populate Sand (if handled as FloorItem)
        // for (Location absLoc : dungeonData.getSandSpawnLocations()) { ... }

        plugin.getLogger().fine("Finished populating floor items for team " + teamId);
    }


    // --- Getters ---
    @NotNull public Location getDungeonOrigin() { return dungeonOrigin.clone(); } // Clone for safety
    @NotNull public World getWorld() { return world; }
    @NotNull public UUID getTeamId() { return teamId; }
    @Nullable public Dungeon getDungeonData() { return dungeonData; } // Can be null before init finishes
    @NotNull public List<PlacedSegment> getPlacedSegmentsInWorld() { return Collections.unmodifiableList(this.placedSegmentsInWorld); }

    /** Finds the PlacedSegment (with absolute world coords) at a given absolute world location within this instance. */
    @Nullable
    public PlacedSegment getSegmentAtLocation(@NotNull Location location) {
        if (world == null || !world.equals(location.getWorld())) {
            return null;
        }
        // Iterate through segments placed in the world for this instance
        for (PlacedSegment segment : placedSegmentsInWorld) {
            // Use the Area's contains method
            if (segment.getWorldBounds().contains(location)) {
                return segment;
            }
        }
        return null;
    }

    /** Removes the blocks and entities associated with this dungeon instance. */
    public void cleanupInstance() {
         plugin.getLogger().info("Attempting cleanup for dungeon instance of team " + teamId);
         // TODO: Implement cleanup logic (e.g., WorldEdit //set air over the bounds)

         placedSegmentsInWorld.clear();
         if (dungeonData != null) {
             // Tell managers to clear state related to this teamId
             vaultManager.clearTeamState(teamId);
             doorManager.clearTeamState(teamId);
             floorItemManager.clearTeamState(teamId);
             dungeonData = null;
         }
         plugin.getLogger().info("Cleanup logic finished for team " + teamId);
     }

}
