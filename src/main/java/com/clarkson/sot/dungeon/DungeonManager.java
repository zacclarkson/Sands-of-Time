package com.clarkson.sot.dungeon;

// Local project imports
import com.clarkson.sot.dungeon.segment.PlacedSegment;
import com.clarkson.sot.dungeon.segment.Segment;
import com.clarkson.sot.entities.Area;
import com.clarkson.sot.dungeon.DoorManager; // Import DoorManager
import com.clarkson.sot.events.FloorItemManager;
import com.clarkson.sot.main.GameManager;
import com.clarkson.sot.main.SoT; // Or just Plugin

// Bukkit/WorldEdit imports
import org.bukkit.Location;
import org.bukkit.Material;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.plugin.Plugin;
import org.bukkit.util.Vector;
import com.sk89q.worldedit.math.BlockVector3;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

// WorldEdit imports for pasting (Example - move to dedicated class later)
import com.sk89q.worldedit.WorldEdit;
import com.sk89q.worldedit.bukkit.BukkitAdapter;
import com.sk89q.worldedit.extent.clipboard.Clipboard;
import com.sk89q.worldedit.extent.clipboard.io.ClipboardFormat;
import com.sk89q.worldedit.extent.clipboard.io.ClipboardFormats;
import com.sk89q.worldedit.extent.clipboard.io.ClipboardReader;
import com.sk89q.worldedit.session.ClipboardHolder;
import com.sk89q.worldedit.EditSession;
import com.sk89q.worldedit.function.operation.Operation;
import com.sk89q.worldedit.function.operation.Operations;
import com.sk89q.worldedit.WorldEditException;


// Java imports
import java.io.File; // For schematic file path
import java.io.FileInputStream; // For schematic reading
import java.io.IOException; // For schematic reading
import java.util.*;
import java.util.logging.Level;
import java.util.stream.Collectors;

/**
 * Manages a specific, live instance of a dungeon for a single team.
 * Takes a DungeonBlueprint, translates it to absolute coordinates,
 * builds the instance in the world using WorldEdit, initializes features,
 * and holds the final Dungeon data object.
 */
public class DungeonManager {

    // --- Dependencies ---
    private final Plugin plugin;
    private final GameManager gameManager;
    // Managers retrieved from GameManager
    private final VaultManager vaultManager;
    private final FloorItemManager floorItemManager;
    private final DoorManager doorManager;
    private final Random random; // Added for probabilities

    // --- Instance State ---
    private final UUID teamId;
    private final Location dungeonOrigin; // Absolute world origin for this instance
    private final World world;
    private final DungeonBlueprint blueprintData; // The relative blueprint used
    private final List<PlacedSegment> placedSegmentsInWorld; // Actual segments placed in the world
    // --- Constants ---
    private static final double SAND_SPAWN_CHANCE = 0.4; // Example: 40% chance for sand to spawn at a location

    // The consolidated data object with ABSOLUTE locations for this instance
    private Dungeon dungeonData;

    /**
     * Constructor for a team's specific DungeonManager instance.
     * Retrieves dependent managers from GameManager.
     *
     * @param plugin           The main plugin instance.
     * @param gameManager      The main GameManager (used to get other managers).
     * @param teamId           The UUID of the team this dungeon belongs to.
     * @param dungeonOrigin    The absolute world location for the origin (0,0,0 point) of this dungeon instance.
     * @param blueprintData    The relative layout blueprint generated by DungeonGenerator.
     */
    /** Constructor */
    public DungeonManager(@NotNull Plugin plugin, @NotNull GameManager gameManager,
                          @NotNull UUID teamId, @NotNull Location dungeonOrigin, @NotNull DungeonBlueprint blueprintData) {

        this.plugin = Objects.requireNonNull(plugin, "Plugin cannot be null");
        this.gameManager = Objects.requireNonNull(gameManager, "GameManager cannot be null");
        this.vaultManager = Objects.requireNonNull(gameManager.getVaultManager(), "VaultManager cannot be null via GameManager");
        this.floorItemManager = Objects.requireNonNull(gameManager.getFloorItemManager(), "FloorItemManager cannot be null via GameManager");
        this.doorManager = Objects.requireNonNull(gameManager.getDoorManager(), "DoorManager cannot be null via GameManager");
        this.teamId = Objects.requireNonNull(teamId, "Team ID cannot be null");
        this.dungeonOrigin = Objects.requireNonNull(dungeonOrigin, "Dungeon origin cannot be null");
        this.world = Objects.requireNonNull(dungeonOrigin.getWorld(), "Dungeon origin must have a valid world");
        this.blueprintData = Objects.requireNonNull(blueprintData, "Dungeon blueprint cannot be null");

        this.placedSegmentsInWorld = new ArrayList<>();
        this.dungeonData = null;
        this.random = new Random(); // Initialize Random
    }
    /**
     * Initializes the dungeon instance in the world.
     * 1. Calculates absolute locations for features.
     * 2. Pastes segments based on the absolute locations.
     * 3. Creates the Dungeon data object.
     * 4. Initializes Vaults, Keys, Doors, and FloorItems using their respective managers.
     *
     * @return true if initialization was generally successful, false otherwise.
     */
    public boolean initializeInstance() {
        plugin.getLogger().info("Initializing dungeon instance for team " + teamId + " at origin " + dungeonOrigin.toVector());

        // --- 1. Calculate Absolute Locations ---
        Map<VaultColor, Location> absVaultMarkers = calculateAbsoluteLocations(blueprintData.getVaultMarkerRelativeLocations());
        Map<VaultColor, Location> absKeySpawns = calculateAbsoluteLocations(blueprintData.getKeySpawnRelativeLocations());
        List<Location> absSandSpawns = calculateAbsoluteLocations(blueprintData.getSandSpawnRelativeLocations());
        List<Location> absCoinSpawns = calculateAbsoluteLocations(blueprintData.getCoinSpawnRelativeLocations());
        List<Location> absItemSpawns = calculateAbsoluteLocations(blueprintData.getItemSpawnRelativeLocations());
        Location absHubLocation = dungeonOrigin.clone().add(blueprintData.getHubRelativeLocation());


        // --- 2. Paste Schematics (Populates placedSegmentsInWorld) ---
        if (!pasteSegmentSchematics()) {
             plugin.getLogger().severe("Failed to paste one or more schematics for team " + teamId);
             return false;
        }
        plugin.getLogger().info("Pasted all " + placedSegmentsInWorld.size() + " segment schematics for team " + teamId);


        // --- 3. Create Dungeon Data Object ---
        // Now created *after* pasting. Uses the calculated absolute locations.
        // The Dungeon constructor no longer takes the PlacedSegment list.
         try {
            this.dungeonData = new Dungeon(
                teamId, world, dungeonOrigin, blueprintData, // Pass blueprint ref
                absHubLocation, absVaultMarkers, absKeySpawns,
                absSandSpawns, absCoinSpawns, absItemSpawns
            );
             plugin.getLogger().info("Created Dungeon data object for team " + teamId);
         } catch (Exception e) {
             plugin.getLogger().log(Level.SEVERE, "Exception creating Dungeon data object for team " + teamId, e);
             return false;
         }


        // --- 4. Initialize Features using Managers ---
        // These managers use the absolute locations stored in dungeonData
        try {
            vaultManager.initializeForInstance(this.dungeonData);
            doorManager.initializeDoorsForInstance(this.dungeonData); // Initialize doors
            populateFloorItems(); // Spawn floor items
        } catch (Exception e) {
             plugin.getLogger().log(Level.SEVERE, "Error during feature manager initialization for team " + teamId, e);
             return false;
        }

        plugin.getLogger().info("Successfully initialized dungeon instance for team " + teamId);
        return true;
    }

    // createDungeonDataObject() removed as logic moved into initializeInstance()

    /** Helper to convert relative map to absolute map */
    private Map<VaultColor, Location> calculateAbsoluteLocations(Map<VaultColor, Vector> relativeMap) {
        Map<VaultColor, Location> absoluteMap = new HashMap<>();
        for (Map.Entry<VaultColor, Vector> entry : relativeMap.entrySet()) {
            absoluteMap.put(entry.getKey(), dungeonOrigin.clone().add(entry.getValue()));
        }
        return absoluteMap;
    }

    /** Helper to convert relative list to absolute list */
    private List<Location> calculateAbsoluteLocations(List<Vector> relativeList) {
        return relativeList.stream()
                           .map(vec -> dungeonOrigin.clone().add(vec))
                           .collect(Collectors.toList());
    }


    /** Pastes all segment schematics into the world using a single EditSession. */
    private boolean pasteSegmentSchematics() {
        this.placedSegmentsInWorld.clear();
        boolean overallSuccess = true; // Track if any paste fails

        // Adapt world once
        com.sk89q.worldedit.world.World weWorld = BukkitAdapter.adapt(world);

        // Create a single EditSession for all paste operations in this instance
        try (EditSession editSession = WorldEdit.getInstance().newEditSessionBuilder().world(weWorld).build()) {
            for (PlacedSegment blueprintSegment : blueprintData.getRelativeSegments()) {
                Segment template = blueprintSegment.getSegmentTemplate();
                Vector relativeOriginVec = blueprintSegment.getWorldOrigin().toVector();
                Location absoluteOriginLoc = dungeonOrigin.clone().add(relativeOriginVec);

                // Call pasting logic, passing the single EditSession
                boolean success = pasteSchematic(template, absoluteOriginLoc, editSession); // Pass session
                if (!success) {
                    plugin.getLogger().severe("Failed to paste schematic '" + template.getSchematicFileName() + "' for team " + teamId + " at " + absoluteOriginLoc.toVector());
                    overallSuccess = false; // Mark failure but continue pasting others if desired
                    // return false; // Option: Stop immediately on first failure
                } else {
                     // Only add to placedSegmentsInWorld if successfully pasted
                     PlacedSegment worldSegment = new PlacedSegment(template, absoluteOriginLoc, blueprintSegment.getDepth());
                     this.placedSegmentsInWorld.add(worldSegment);
                     plugin.getLogger().finer("Pasted segment " + template.getName() + " for team " + teamId + " at " + absoluteOriginLoc.toVector());
                }
            }
            // Optional: Flush the session once after all operations are queued
            // Operations are usually completed implicitly when the try-with-resources block closes the session.
            // editSession.flushSession();
            plugin.getLogger().fine("Completed pasting operations for team " + teamId);

        } catch (Exception e) { // Catch unexpected errors
             plugin.getLogger().log(Level.SEVERE, "Unexpected error during paste session for team " + teamId, e);
             return false;
        }

        return overallSuccess; // Return true only if all pastes succeeded
    }

    /**
     * Pastes a single schematic using WorldEdit within a provided EditSession.
     * @param template The segment template containing schematic info.
     * @param pasteOrigin The absolute world location to paste the schematic at.
     * @param editSession The EditSession to use for the paste operation.
     * @return true if pasting was successful, false otherwise.
     */
    private boolean pasteSchematic(Segment template, Location pasteOrigin, EditSession editSession) { // Added EditSession parameter
        File schematicDir = new File(plugin.getDataFolder(), "schematics");
        File schematicFile = new File(schematicDir, template.getSchematicFileName());

        if (!schematicFile.exists()) {
            plugin.getLogger().severe("Schematic file not found: " + schematicFile.getPath());
            return false;
        }

        try {
            ClipboardFormat format = ClipboardFormats.findByFile(schematicFile);
            if (format == null) {
                 plugin.getLogger().severe("Unknown schematic format: " + schematicFile.getName());
                 return false;
            }
            try (ClipboardReader reader = format.getReader(new FileInputStream(schematicFile))) {
                Clipboard clipboard = reader.read();

                // --- Use the provided EditSession ---
                // No need to create a new one here
                Operation operation = new ClipboardHolder(clipboard)
                        .createPaste(editSession) // Use passed-in session
                        .to(BlockVector3.at(pasteOrigin.getBlockX(), pasteOrigin.getBlockY(), pasteOrigin.getBlockZ()))
                        .ignoreAirBlocks(true) // Paste non-air blocks
                        .build();
                Operations.complete(operation); // Queue and complete the operation within the session
                // --- Removed the local EditSession try-with-resources block ---
            }
            return true;
        } catch (IOException | WorldEditException e) {
             plugin.getLogger().log(Level.SEVERE, "Failed to paste schematic " + template.getSchematicFileName() + " at " + pasteOrigin.toVector(), e);
             return false;
        } catch (Exception e) {
            plugin.getLogger().log(Level.SEVERE, "Unexpected error pasting schematic " + template.getSchematicFileName(), e);
            return false;
        }
    }


    /**
     * Spawns floor items (Coins, Generic Items) using the FloorItemManager
     * and places Sand blocks probabilistically based on the absolute locations
     * stored in the `dungeonData` object. Called by `initializeInstance`.
     */
    private void populateFloorItems() {
        // Ensure data is ready
        if (dungeonData == null) {
            plugin.getLogger().severe("Cannot populate floor items: Dungeon data object is null for team " + teamId);
            return;
        }
        if (floorItemManager == null) {
             plugin.getLogger().severe("Cannot populate floor items: FloorItemManager is null!");
             // Possibly throw an exception or return early depending on how critical floor items are
             return;
        }

        plugin.getLogger().fine("Populating floor items for team " + teamId + " instance " + dungeonData.getInstanceId());
        UUID instanceUUID = dungeonData.getInstanceId();

        // --- Populate Coins ---
        List<Location> coinLocs = dungeonData.getCoinSpawnLocations();
        if (coinLocs != null && !coinLocs.isEmpty()) {
            plugin.getLogger().finer("Processing " + coinLocs.size() + " potential coin spawn locations.");
            for (Location absLoc : coinLocs) {
                if (absLoc == null) continue;
                try {
                    int depth = dungeonData.getDepthAtLocation(absLoc, this.placedSegmentsInWorld);
                    int baseValue = 5 + (depth / 2);
                    floorItemManager.spawnCoinStack(absLoc, baseValue, teamId, instanceUUID, depth);
                } catch (Exception e) {
                    plugin.getLogger().log(Level.WARNING, "Error processing coin spawn at " + absLoc + " for team " + teamId, e);
                }
            }
        } else {
             plugin.getLogger().finer("No coin spawn locations found for team " + teamId);
        }

        // --- Populate Generic Items ---
        List<Location> itemLocs = dungeonData.getItemSpawnLocations();
        if (itemLocs != null && !itemLocs.isEmpty()) {
            plugin.getLogger().finer("Processing " + itemLocs.size() + " potential item spawn locations.");
            for (Location absLoc : itemLocs) {
                 if (absLoc == null) continue;
                 try {
                     int depth = dungeonData.getDepthAtLocation(absLoc, this.placedSegmentsInWorld);
                     floorItemManager.spawnGenericItem(absLoc, teamId, instanceUUID, depth);
                 } catch (Exception e) {
                     plugin.getLogger().log(Level.WARNING, "Error processing item spawn at " + absLoc + " for team " + teamId, e);
                 }
            }
        } else {
             plugin.getLogger().finer("No generic item spawn locations found for team " + teamId);
        }

        // --- Populate Sand (Place block probabilistically) ---
        List<Location> sandLocs = dungeonData.getSandSpawnLocations();
        int sandPlacedCount = 0;
        if (sandLocs != null && !sandLocs.isEmpty()) {
             plugin.getLogger().finer("Processing " + sandLocs.size() + " potential sand spawn locations (Chance: " + (SAND_SPAWN_CHANCE * 100) + "%).");
             for (Location absLoc : sandLocs) {
                  if (absLoc == null) continue;
                  try {
                      // Check probability
                      if (random.nextDouble() < SAND_SPAWN_CHANCE) {
                          Block block = absLoc.getBlock();
                          // Place sand if the block is replaceable (air, water, maybe tall grass etc.)
                          if (block.isPassable() || block.getType().isAir() || block.isLiquid()) {
                              block.setType(Material.SAND, false); // false = don't cause physics updates yet
                              sandPlacedCount++;
                          } else {
                               plugin.getLogger().finer("Skipped sand placement at " + absLoc.toVector() + ": Block not replaceable (" + block.getType() + ")");
                          }
                      }
                  } catch (Exception e) {
                     plugin.getLogger().log(Level.WARNING, "Error processing sand spawn at " + absLoc + " for team " + teamId, e);
                  }
             }
             plugin.getLogger().fine("Placed " + sandPlacedCount + " sand blocks out of " + sandLocs.size() + " potential locations.");
        } else {
             plugin.getLogger().finer("No sand spawn locations found for team " + teamId);
        }

        plugin.getLogger().fine("Finished populating floor items for team " + teamId);
    }


    // --- Getters ---
    @NotNull public Location getDungeonOrigin() { return dungeonOrigin.clone(); } // Clone for safety
    @NotNull public World getWorld() { return world; }
    @NotNull public UUID getTeamId() { return teamId; }
    @Nullable public Dungeon getDungeonData() { return dungeonData; } // Can be null before init finishes
    @NotNull public List<PlacedSegment> getPlacedSegmentsInWorld() { return Collections.unmodifiableList(this.placedSegmentsInWorld); }

    /** Finds the PlacedSegment (with absolute world coords) at a given absolute world location within this instance. */
    @Nullable
    public PlacedSegment getSegmentAtLocation(@NotNull Location location) {
        if (world == null || !world.equals(location.getWorld())) {
            return null;
        }
        // Iterate through segments placed in the world for this instance
        for (PlacedSegment segment : placedSegmentsInWorld) {
            // Use the Area's contains method
            if (segment.getWorldBounds().contains(location)) {
                return segment;
            }
        }
        return null;
    }

    /** Removes the blocks and entities associated with this dungeon instance. */
    public void cleanupInstance() {
         plugin.getLogger().info("Attempting cleanup for dungeon instance of team " + teamId);
         // TODO: Implement cleanup logic (e.g., WorldEdit //set air over the bounds)

         placedSegmentsInWorld.clear();
         if (dungeonData != null) {
             // Tell managers to clear state related to this teamId
             vaultManager.clearTeamState(teamId);
             doorManager.clearTeamState(teamId);
             floorItemManager.clearTeamState(teamId);
             dungeonData = null;
         }
         plugin.getLogger().info("Cleanup logic finished for team " + teamId);
     }

}
